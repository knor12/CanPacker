/*
*this file is auto generated by  CanPacker version V0.06.
*@file ./description.csv
*@date 2023-05-06
*@author n.kessa
*@brief frame packer/unpacker ./description.csv
*/




#ifdef __cplusplus
extern "C"
{
#endif		/* __cplusplus */


#include "CAN_DEVICE.h"
#include <stdbool.h>






/* packing "	send device health data to others		"*/
bool HEALTH_pack(
    const uint32_t ID,
    uint8_t * pU8Data
    /*uint32_t HEALTH_MULTIPLEXOR */ /*key */ /*is a constant no argument is used*/
    /*uint16_t  VOLTAGe_HEALTH */  /*value gotton from get_voltageUpdate()*/
    /*uint16_t  CURRENTHEALTH */  /*value gotton from get_current()*/
    /*ON_OFF_t  IO */  /*value gotton from get_IO()*/ )
{
    (void)ID; /*not used for now*/

    /*nothing to do if invalid data pointer provided*/
    if (pU8Data==0)
    {
        return false;
    }

    uint64_t * pU64Data = (uint64_t *)(pU8Data);
    * pU64Data = 0u;
    /*packing HEALTH_MULTIPLEXOR*/
    *pU64Data = (*pU64Data ) | (((uint64_t)(0x12&0xff))<<4);
    /*packing VOLTAGe_HEALTH*/
    *pU64Data = (*pU64Data ) | (((uint64_t)(get_voltageUpdate())& 0x3f)<<20);
    /*packing CURRENTHEALTH*/
    *pU64Data = (*pU64Data ) | (((uint64_t)(get_current())& 0xff)<<32);
    /*packing IO*/
    *pU64Data = (*pU64Data ) | (((uint64_t)(get_IO())& 0x7)<<40);
    return true;
}

/* packing "	resets device		"*/
bool RESET_pack(
    const uint32_t ID,
    uint8_t * pU8Data
    /*uint32_t RESET_CONSTANT */  /*is a constant no argument is used*/)
{
    (void)ID; /*not used for now*/

    /*nothing to do if invalid data pointer provided*/
    if (pU8Data==0)
    {
        return false;
    }

    uint64_t * pU64Data = (uint64_t *)(pU8Data);
    * pU64Data = 0u;
    /*packing RESET_CONSTANT*/
    *pU64Data = (*pU64Data ) | (((uint64_t)(0x01020304&0xffffffff))<<7);
    return true;
}




/* unpacking "	send device health data to others		"*/
bool HEALTH_unpack(
    const uint32_t ID,
    const uint8_t * pU8Data
    /*uint32_t HEALTH_MULTIPLEXOR*/ /*key */ /*is a constant no argument is used*/
    /*uint16_t * VOLTAGe_HEALTH*/  /*value set to set_voltageUpdate()*/
    /*uint16_t * CURRENTHEALTH*/  /*value set to set_current()*/
    /*ON_OFF_t * IO*/  /*value set to set_IO_ON_OFF()*/ )
{
    /*nothing to do if invalid data pointer provided*/
    if (pU8Data==0)
    {
        return false;
    }

    uint64_t * pU64Data = (uint64_t *)(pU8Data);

    /*check ID match*/
    if (10 != ID)
    {
        return false;
    }

    /*unpacking HEALTH_MULTIPLEXOR*/
    uint32_t _HEALTH_MULTIPLEXOR = (uint32_t)(((* pU64Data)>>4)&0xff);

    if(_HEALTH_MULTIPLEXOR!=0x12)
    {
        return false;
    }

    /*unpacking VOLTAGe_HEALTH*/
    uint16_t _VOLTAGe_HEALTH = (uint16_t)(((* pU64Data)>>20)&0x3f);
    set_voltageUpdate(_VOLTAGe_HEALTH);
    /*unpacking CURRENTHEALTH*/
    uint16_t _CURRENTHEALTH = (uint16_t)(((* pU64Data)>>32)&0xff);
    set_current(_CURRENTHEALTH);
    /*unpacking IO*/
    ON_OFF_t _IO = (ON_OFF_t)(((* pU64Data)>>40)&0x7);
    set_IO_ON_OFF(_IO);
    return true;
}

/* unpacking "	resets device		"*/
bool RESET_unpack(
    const uint32_t ID,
    const uint8_t * pU8Data
    /*uint32_t RESET_CONSTANT*/  /*is a constant no argument is used*/)
{
    /*nothing to do if invalid data pointer provided*/
    if (pU8Data==0)
    {
        return false;
    }

    uint64_t * pU64Data = (uint64_t *)(pU8Data);

    /*check ID match*/
    if (0x1233 != ID)
    {
        return false;
    }

    /*unpacking RESET_CONSTANT*/
    uint32_t _RESET_CONSTANT = (uint32_t)(((* pU64Data)>>7)&0xffffffff);

    if(_RESET_CONSTANT!=0x01020304)
    {
        return false;
    }

    set_resetDeviceNow(_RESET_CONSTANT);
    return true;
}



void CAN_DEVICE_cyclic(void)
{
    /**send frame HEALTH on change.**/
    static uint64_t u64HEALTH_old_data = 0;
    uint64_t u64HEALTH_now_data  = 0;
    /*built the new frame*/
    HEALTH_pack( 10, (uint8_t *)(&u64HEALTH_now_data));

    /*see if frame has changed*/
    if (u64HEALTH_old_data != u64HEALTH_now_data)
    {
        /*send the frame*/
        CAN_DEVICE_sendFrame(10, (uint8_t *) (&u64HEALTH_now_data));
        /*save copy of data sent.*/
        u64HEALTH_old_data = u64HEALTH_now_data;
    }

    /**send frame HEALTH cyclically.**/
    /*define a counter*/
    static uint32_t HEALTH_counterMs = 0;

    /*initialize the counter*/
    if (HEALTH_counterMs==0)
    {
        HEALTH_counterMs = CAN_DEVICE_ticksMs();
    }

    /*see if the time is up for sendig the frame.*/
    if (10 <= CAN_DEVICE_ticksSince(HEALTH_counterMs))
    {
        uint64_t u64HEALTH_now_data  = 0;
        /*pack the frame to be sent*/
        HEALTH_pack( 10, (uint8_t *)(&u64HEALTH_now_data));
        /*send the frame*/
        CAN_DEVICE_sendFrame(10, (uint8_t *) (&u64HEALTH_now_data));
        /*reset the counter for next iteration*/
        HEALTH_counterMs = CAN_DEVICE_ticksMs();
    }
}





void CAN_DEVICE_parse(uint32_t id, uint8_t * pData)
{
    if(10==id)
    {
        HEALTH_unpack(id, pData);
    }

    if(0x1233==id)
    {
        RESET_unpack(id, pData);
    }
}

#ifdef __cplusplus
}
#endif		/* __cplusplus */
